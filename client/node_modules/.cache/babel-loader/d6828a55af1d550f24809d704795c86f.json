{"ast":null,"code":"'use strict';\n\nclass DOMHelper {\n  /**\r\n   * Attaches events to the given element.\r\n   *\r\n   * @param el\r\n   * @param events\r\n   * @param callback\r\n   * @param options\r\n   */\n  static addEventListener(el, events, callback, options = true) {\n    for (let i in events) {\n      el.addEventListener(events[i], callback, options);\n    }\n  }\n  /**\r\n   * Removes events from the given element.\r\n   *\r\n   * @param el\r\n   * @param events\r\n   * @param callback\r\n   * @param options\r\n   */\n\n\n  static removeEventListener(el, events, callback, options = true) {\n    for (let i in events) {\n      el.removeEventListener(events[i], callback, options);\n    }\n  }\n  /**\r\n   * Attaches events to the given element for once.\r\n   *\r\n   * @param el\r\n   * @param events\r\n   * @param callback\r\n   * @param addOptions\r\n   * @param removeOptions\r\n   */\n\n\n  static addEventListenerOnce(el, events, callback, addOptions = true, removeOptions = true) {\n    let cb = e => {\n      this.removeEventListener(el, events, cb, removeOptions);\n      callback(e);\n    };\n\n    this.addEventListener(el, events, cb, addOptions);\n  }\n  /**\r\n   * Checks if target is a clickable element.\r\n   *\r\n   * @param target\r\n   * @param container\r\n   */\n\n\n  static checkIfTargetIsClickable(target, container) {\n    let status = true;\n\n    while (container.contains(target)) {\n      if (target.getAttribute(\"data-src-not-clickable\")) {\n        status = false;\n        break;\n      }\n\n      target = target.parentNode;\n    }\n\n    return status;\n  }\n  /**\r\n   * Gets breakpoint key by window size.\r\n   *\r\n   * @param sb\r\n   * @param theme\r\n   */\n\n\n  static getBreakpointKey({\n    size,\n    sizeSm,\n    sizeMd,\n    sizeLg,\n    sizeXl\n  }, theme) {\n    const width = window.innerWidth;\n    let key = size;\n    if (sizeSm && width > theme.grid.breakpoint.small) key = sizeSm;\n    if (sizeMd && width > theme.grid.breakpoint.medium) key = sizeMd;\n    if (sizeLg && width > theme.grid.breakpoint.large) key = sizeLg;\n    if (sizeXl && width > theme.grid.breakpoint.xlarge) key = sizeXl;\n    return key;\n  }\n  /**\r\n   * Gets scroll parent of the given element.\r\n   *\r\n   * @param el\r\n   */\n\n\n  static getScrollParent(el) {\n    for (let parent = el; parent = parent.parentElement;) {\n      let style = window.getComputedStyle(parent, null);\n      if (/(auto|scroll|hidden)/.test(style.overflow + style.overflowX + style.overflowY)) return parent;\n    }\n\n    return null;\n  }\n  /**\r\n   * Checks if an element can be rendered in the React portal.\r\n   *\r\n   * @param renderInPortal\r\n   */\n\n\n  static canBeRenderedInPortal(renderInPortal) {\n    return renderInPortal && typeof window !== \"undefined\" && process.env.NODE_ENV !== \"test\" ? true : false;\n  }\n\n}\n\nDOMHelper.TRANSITION_END = [\"transitionend\", \"webkitTransitionEnd\", \"mozTransitionEnd\", \"oTransitionEnd\"];\nDOMHelper.MOUSE_WHEEL = [\"wheel\", \"mousewheel\", \"DOMMouseScroll\"];\nDOMHelper.requestAnimationFrame = typeof window !== 'undefined' ? window.mozRequestAnimationFrame || window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || (callback => {\n  window.setTimeout(callback, 1000 / 60);\n}) : () => {};\nDOMHelper.isServer = typeof window === \"undefined\";\nDOMHelper.isMobile = DOMHelper.isServer ? false : /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);\nexports.DOMHelper = DOMHelper;","map":{"version":3,"sources":["/Users/mac/Documents/mern stack/photoShare/client/node_modules/smart-react-components/DOMHelper-c0bd5a29.js"],"names":["DOMHelper","addEventListener","el","events","callback","options","i","removeEventListener","addEventListenerOnce","addOptions","removeOptions","cb","e","checkIfTargetIsClickable","target","container","status","contains","getAttribute","parentNode","getBreakpointKey","size","sizeSm","sizeMd","sizeLg","sizeXl","theme","width","window","innerWidth","key","grid","breakpoint","small","medium","large","xlarge","getScrollParent","parent","parentElement","style","getComputedStyle","test","overflow","overflowX","overflowY","canBeRenderedInPortal","renderInPortal","process","env","NODE_ENV","TRANSITION_END","MOUSE_WHEEL","requestAnimationFrame","mozRequestAnimationFrame","webkitRequestAnimationFrame","oRequestAnimationFrame","msRequestAnimationFrame","setTimeout","isServer","isMobile","navigator","userAgent","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nclass DOMHelper {\r\n    /**\r\n     * Attaches events to the given element.\r\n     *\r\n     * @param el\r\n     * @param events\r\n     * @param callback\r\n     * @param options\r\n     */\r\n    static addEventListener(el, events, callback, options = true) {\r\n        for (let i in events) {\r\n            el.addEventListener(events[i], callback, options);\r\n        }\r\n    }\r\n    /**\r\n     * Removes events from the given element.\r\n     *\r\n     * @param el\r\n     * @param events\r\n     * @param callback\r\n     * @param options\r\n     */\r\n    static removeEventListener(el, events, callback, options = true) {\r\n        for (let i in events) {\r\n            el.removeEventListener(events[i], callback, options);\r\n        }\r\n    }\r\n    /**\r\n     * Attaches events to the given element for once.\r\n     *\r\n     * @param el\r\n     * @param events\r\n     * @param callback\r\n     * @param addOptions\r\n     * @param removeOptions\r\n     */\r\n    static addEventListenerOnce(el, events, callback, addOptions = true, removeOptions = true) {\r\n        let cb = (e) => {\r\n            this.removeEventListener(el, events, cb, removeOptions);\r\n            callback(e);\r\n        };\r\n        this.addEventListener(el, events, cb, addOptions);\r\n    }\r\n    /**\r\n     * Checks if target is a clickable element.\r\n     *\r\n     * @param target\r\n     * @param container\r\n     */\r\n    static checkIfTargetIsClickable(target, container) {\r\n        let status = true;\r\n        while (container.contains(target)) {\r\n            if (target.getAttribute(\"data-src-not-clickable\")) {\r\n                status = false;\r\n                break;\r\n            }\r\n            target = target.parentNode;\r\n        }\r\n        return status;\r\n    }\r\n    /**\r\n     * Gets breakpoint key by window size.\r\n     *\r\n     * @param sb\r\n     * @param theme\r\n     */\r\n    static getBreakpointKey({ size, sizeSm, sizeMd, sizeLg, sizeXl }, theme) {\r\n        const width = window.innerWidth;\r\n        let key = size;\r\n        if (sizeSm && width > theme.grid.breakpoint.small)\r\n            key = sizeSm;\r\n        if (sizeMd && width > theme.grid.breakpoint.medium)\r\n            key = sizeMd;\r\n        if (sizeLg && width > theme.grid.breakpoint.large)\r\n            key = sizeLg;\r\n        if (sizeXl && width > theme.grid.breakpoint.xlarge)\r\n            key = sizeXl;\r\n        return key;\r\n    }\r\n    /**\r\n     * Gets scroll parent of the given element.\r\n     *\r\n     * @param el\r\n     */\r\n    static getScrollParent(el) {\r\n        for (let parent = el; (parent = parent.parentElement);) {\r\n            let style = window.getComputedStyle(parent, null);\r\n            if (/(auto|scroll|hidden)/.test(style.overflow + style.overflowX + style.overflowY))\r\n                return parent;\r\n        }\r\n        return null;\r\n    }\r\n    /**\r\n     * Checks if an element can be rendered in the React portal.\r\n     *\r\n     * @param renderInPortal\r\n     */\r\n    static canBeRenderedInPortal(renderInPortal) {\r\n        return (renderInPortal && typeof window !== \"undefined\" && process.env.NODE_ENV !== \"test\") ? true : false;\r\n    }\r\n}\r\nDOMHelper.TRANSITION_END = [\"transitionend\", \"webkitTransitionEnd\", \"mozTransitionEnd\", \"oTransitionEnd\"];\r\nDOMHelper.MOUSE_WHEEL = [\"wheel\", \"mousewheel\", \"DOMMouseScroll\"];\r\nDOMHelper.requestAnimationFrame = typeof window !== 'undefined'\r\n    ?\r\n        window.mozRequestAnimationFrame ||\r\n            window.requestAnimationFrame ||\r\n            window.webkitRequestAnimationFrame ||\r\n            window.oRequestAnimationFrame ||\r\n            window.msRequestAnimationFrame ||\r\n            ((callback) => { window.setTimeout(callback, 1000 / 60); })\r\n    : () => { };\r\nDOMHelper.isServer = typeof window === \"undefined\";\r\nDOMHelper.isMobile = DOMHelper.isServer ? false : /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);\n\nexports.DOMHelper = DOMHelper;\n"]},"metadata":{},"sourceType":"script"}